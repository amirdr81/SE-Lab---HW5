# SELab_Ex5

---

## نصب YourKit

ابتدا YourKit را مطابق دستور عمل داده شده نصب کردیم و لایسنس آن را برای مدت 15 روز فعال کردیم. این ابزار به شکل اتوماتیک به قسمت Plugins در نرم افزار Intellij Idea اضافه شد.

---

## یافتن تابع پر مصرف در کلاس JavaCup

برای این منظور کد را به کمک YourKit پروفایل می کنیم تا بخش پرمصرف را بیابیم. نتیجۀ پروفایل کردن در شکل های زیر قابل مشاهده است که نشان می دهد بیشینه مصرف در تابع temp() رخ می دهد.

![](./screenshots/1.png)
![](./screenshots/2.png)
![](./screenshots/3.png)
![](./screenshots/4.png)

با بررسی بیشتر به این نتیجه می رسیم که این حجم مصرف به دلیل استفاده از ArrayList است که تعداد 10000\*20000 عنصر، به آن اضافه می شود؛ ولی در هنگام تعریف کردن این ArrayList اندازۀ آن تعریف نمی شود.

---

## بهینه سازی تابع ()temp

به منظور بهینه سازی این تابع بایستی از داده ساختارهای دیگر به همراه اندازۀ از پیش تعیین شده استفاده کرد. در ادامه نتایج پروفایل کردن چند داده ساختار متفاوت را می بینیم.

1. تعریف سایز مشخص برای ArrayList

   ![](./screenshots/5.png)
   ![](./screenshots/6.png)
   ![](./screenshots/7.png)
   ![](./screenshots/8.png)

2. استفاده از ArrayDeque

   ![](./screenshots/13.png)
   ![](./screenshots/14.png)
   ![](./screenshots/15.png)
   ![](./screenshots/16.png)

3. استفاده از آرایۀ int با اندازۀ مشخص

   ![](./screenshots/9.png)
   ![](./screenshots/10.png)
   ![](./screenshots/11.png)
   ![](./screenshots/12.png)

4. استفاده از LinkedList
   ![](./screenshots/17.png)
   ![](./screenshots/18.png)
   ![](./screenshots/19.png)
   ![](./screenshots/20.png)

همان طور که ملاحضه می کنیم، وقتی از آرایۀ int با اندازۀ از پیش تعریف شده استفاده می کنیم، بهترین نتیجه حاصل می شود.

## قسمت دوم - پروفایل و بهینه‌سازی کد جاوا با YourKit

در این بخش، نیاز است تا یک کد جاوا بنویسیم که از الگوریتم فیبوناچی و یا مرتب سازی، متمایز باشد و بعد، با استفاده از yourkit، تحلیل کنیم که کدام قسمت کد در حال مصرف بیش از اندازه پردازنده ما بوده و در نهایت، اقدام به بهینه سازی آن کنیم.
بدین منظور، کد جاوا نوشته شده(در فایل Counter.java) را نوشته که هدف اصلی آن، شمارش دفعات تکرار باقیمانده‌های حاصل از تقسیم اعداد بر 1000 است. برای این منظور از یک نقشه (Map) برای ذخیره تعداد تکرار هر باقیمانده استفاده شده است. پس از اجرای برنامه، اندازه نقشه (که نشان‌دهنده تعداد کل باقیمانده‌های مختلف است) چاپ می‌شود. این عملیات برای اعداد ۱ تا ۱،۰۰۰،۰۰۰،۰۰۰ انجام می‌شود و از HashMap برای ذخیره سازی باقی مانده ها نسبت به عدد ۱۰۰۰ استفاده می‌کنیم(کلید ها، اعداد ۰ الی ۹۹۹ بوده و value ها، تعداد تکرر هر یک از کلید ها می‌باشند). در نهایت، در خروجی کد بعد از اجرا، اندازه این نقشه(Map) به ما نمایش داده می‌شود.

این تکه کد، در هر گام، برای هر یک از اعداد ۰ الی ۹۹۹، ابتدا با استفاده از تابع containsKey بررسی می‌کند که آیا کلید متناظر در نقشه ما وجود دارد یا خیر، در صورت وجود، مقدار کلید آن‌را ۱ واحد افزایش داده و در صورت عدم وجود، کلید را به نقشه اضافه می‌کند.
